:root {
  /* Wird während der Layoutphase zum Kennzeichnen der Container benutzt */
  --layout-border: thin dotted darkgrey;

  /* Anwendungsweite Variablen */
  --app-spacing: 1rem;
  --app-transition: 0.2s ease-in-out;
  --background-color: white;
}



/* Reset */
*,
*:before,
*:after {
  box-sizing: inherit;
  margin: 0;
  padding: 0;
}

:root {
  box-sizing: border-box;
  min-height: 100%;
}

body {
  min-height: 100vh;
  font-size: 100%;
  line-height: 1.5;
}

img,
video,
canvas,
audio,
iframe,
embed,
object {
  display: block;
  max-width: 100%;
}

input,
button,
textarea,
select {
  font-family: inherit;
  font-size: inherit;
}

/* Typography */

body {
  font-family: Arial, Helvetica, sans-serif;
}

/* Vertikale Abstände */
article,
section,
table,
form,
div {
  margin-bottom: 1rem;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  margin-bottom: 0.5rem;
}

p,
pre {
  margin-bottom: 0.5rem;
}

p {
  text-wrap: pretty;
}

/* Klassenlose HTML Struktur - globales Layout */
/*
<body>
  <header></header>
  <aside></aside>
  <nav></nav>
  <main></main>
  <footer></footer
</body>
*/

body {
  display: grid;
  grid-template-areas:
    "sidebar header"
    "sidebar content"
    "footer footer";

  /* Sidebar nimmt sich soviel Platz, wie sie benötigt; Der Inhaltsbereich wächst mit der Fenstergröße.*/
  grid-template-columns: auto 1fr;

  header {
    grid-area: header;
  }

  main {
    grid-area: content;
  }

  aside {
    grid-area: sidebar;

  }

  footer {
    grid-area: footer;
  }
}

/* Das könnte später mal main sein. */
/* Rekursives full-width ist nicht implementiert. */
.content-grid {
  --padding-inline: 2rem;
  --content-max-midth: 70ch;
  --breakout-max-width: 85ch;

  --breakout-size: calc((var(--breakout-max-width) - var(--content-max-midth)) / 2);

  display: grid;
  grid-template-columns:
    [full-width-start] minmax(var(--padding-inline), 1fr) [breakout-start] minmax(0, var(--breakout-size)) [content-start] min(100% - (var(--padding-inline) * 2), var(--content-max-midth)) [content-end] minmax(0, var(--breakout-size)) [breakout-end] minmax(var(--padding-inline), 1fr) [full-width-end];
}

.content-grid>* {
  grid-column: content;
}

.content-grid>.breakout {
  grid-column: breakout;
}

.content-grid>.full-width {
  grid-column: full-width;
}

header {
  margin: 0 0.25rem;

  display: flex;
  flex-flow: row nowrap;
  justify-content: space-between;
  align-items: center;

  form {
    display: flex;
  }

  >*:not(:first-child) {
    margin-left: 0.5rem;
  }

  >*:not(:last-child) {
    margin-right: 0.5rem;
  }
}

.fill {
  flex-grow: 1;
}

nav {
  a {
    text-decoration: none;
  }

  ul,
  menu {
    padding: 0;
    margin: 0;
  }
}

header nav {

  border: var(--layout-border);
  display: inline-block;

  ul,
  menu {
    position: relative;
    display: flex;
    list-style-type: none;

    li {

      a {
        text-decoration: none;
      }

      ul,
      menu {
        background-color: var(--background-color);
        visibility: hidden;
        opacity: 0;
        position: absolute;
        display: block;
      }

      &:hover {

        ul,
        menu {
          visibility: visible;
          opacity: 1;
        }
      }
    }
  }
}

aside,
main,
nav,
header,
footer {
  outline: var(--layout-border);
}

/* Von der Breite beschränkte und zentrierte Elemente des Hauptbereichs */

main>form {
  max-width: 570px;
  margin: auto;
}

main>table {
  /* max-width: 570px; */
  margin: auto;
}


/* Kartenansicht */

/* Detailansicht */
/* Da muss ein anderer Selektor hin. Darf sich aber nicht mit Karten und Listenansicht überschneiden */
main section.details {
  max-width: 570px;
  margin: auto;
  /* text-align: center; */

  figure {
    width: fit-content;
    margin: 0 auto;

    img {
      display: block;
    }
  }
}

dl,
dl div {
  border: var(--layout-border);

  display: grid;
  grid-template-columns: [term] max-content [description] 1fr;
  grid-auto-rows: auto;
  grid-auto-flow: dense;
  gap: 1px;

  /* div Element erstreckt sich über beide Spalten */
  div {
    grid-column: span 2;
  }

  /* Dem div Element folgt eine Trennlinie. Ist das div Element das letzte
  Kindelement, folgt keine Trennlinie*/
  div:not(:last-child) {
    border-bottom: 1px solid black;
  }

  dt {
    grid-column: term;
    justify-self: start;
  }

  /* Wenn die Beschreibung zwei Terms vorausgegangen sind, erstreckt sich die Beschreibung über zwei Zeilen */
  dt+dt+dd {
    grid-row: span 2;
  }

  dd {
    grid-column: description;
    justify-self: end;
    align-self: center;
    border: var(--layout-border);
  }

  /* Wenn einer Beschreibung zwei Terms folgen, erstreckt sich die Beschreibung über zwei Zeilen */
  dt:has(+ dd + dd) {
    grid-row: span 2;
    align-self: center;
  }
}

details.dropdown {
  position: relative;

  summary~* {
    display: flex;
    flex-direction: column;
    position: absolute;
    right: 0;
    width: 100%;

    min-width: fit-content;
    margin: 0;
    padding: 0;
    border: var(--layout-border);
    z-index: 99;
    opacity: 1;
    background-color: var(--background-color)
  }
}

fieldset {
  margin: 0;
  padding: 0;
  border: none;
  display: flex;
  flex-direction: column;
}

details {
  display: block;
}

details summary {
  cursor: pointer;
  line-height: 1rem;
  list-style-type: none;
}

details summary::after {
  display: block;
  width: 1rem;
  height: 1rem;
  margin-inline-start: calc(var(--app-spacing, 1rem) * 0.5);
  float: right;
  content: ">";
  transition: transform var(--app-transition)
}

details[open] summary::after {
  transform: rotate(90deg);
}

/* Cards */

/* Effekte */
/* Bei Karten mit Fokus oder Hover das enthaltene Bild heranzoomen und einen Schatten erzeugen */
main>ul {
  padding: 1rem;

  >li {
    --image-scale: 1.001;
    overflow: hidden;
    transform-origin: center;
    background-color: var(--background-color);
    margin: 0;

    img {
      max-width: 100%;
      transform-origin: center;
      transform: scale(var(--img-scale));
      transition: transform 0.4s ease-in-out;
    }

    div {
      padding: 0.5rem;
    }

    /* Links mit Fokus durch einen Rahmen hervorheben */
    a:focus {
      outline: 1px dotted #28666e;
    }
  }

  /* Aktive Karten hervorheben */
  >li:has(:hover, :focus) {
    --img-scale: 1.1;
    box-shadow: rgba(0, 0, 0, 0.16) 0px 10px 36px 0px, rgba(0, 0, 0, 0.06) 0px 0px 0px 1px;
  }
}

/* Layout für Karten in einem Raster. Die Rasterfläche muss ein article Element sein; jede Karte ist ein section Element innerhalb des article Elements.*/
main>ul {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;

  >li {
    /* Karten müssen eine feste Breite besitzen */
    width: 300px;
    position: relative;
    outline: var(--layout-border);

    a {
      text-decoration: none;
    }

    /* Der Trick, dass Karten anklickbar sind */
    a::after {
      position: absolute;
      inset-block: 0;
      inset-inline: 0;
      cursor: pointer;
      content: "";
    }
  }
}

/* Listenansicht: Listenansichten sind table Elemente in main */
main table {

  width: 100%;
  min-width: 100%;
  border-collapse: separate;
  border-spacing: 0;
  margin-bottom: 1rem;

  caption {
    text-align: left;
    margin-bottom: 0.5rem;
    font-weight: bold;
  }

  th,
  td {
    border: var(--layout-border);
    text-align: left;
    overflow-wrap: break-word;
    white-space: normal;
  }


  td:has(img) {
    width: 50px;
    overflow: hidden;
    display: inline-block;

    img {
      max-width: 100%;
      max-height: 100%;
      display: block;
    }
  }
}

/* TODO:
Mir bislang unbekannte HTML Elemente:
  menu - Semantisch besser als ul für Menüs.
  hgroup
  output
  search
  slot (Web Component Slot)
  template
  time

Formulare
  Um Formulare wie in GNOME darzustellen, könnte ich fieldsets verwenden
  Ich kann mir das id Attribut für label sparen, wenn das input Element
  ein Kindelement des Labels ist. Labels sind nur für button, input,
  meter, output, progress, select und textare zu gebrauchen.

Um Detailansichten (ähnlich Formulare) zu gestalten könnte ich dl benutzen
Für Akkordeon das details element
*/
